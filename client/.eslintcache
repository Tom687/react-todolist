[{"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/index.js":"1","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/reportWebVitals.js":"2","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/App.js":"3","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/App/store.js":"4","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoSlice.js":"5","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/Filter/FilterSlice.js":"6","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/AddTodoForm.js":"7","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoList.js":"8","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/Filter/Footer.js":"9","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoItem.js":"10","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/Filter/FilterLink.js":"11","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/components/CustomCheckbox/CustomCheckbox.js":"12","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/components/InlineEdit/InlineEdit.js":"13","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/hooks/useKeyPress.js":"14","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/hooks/useOnClickOutside.js":"15","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoItempp.js":"16"},{"size":611,"mtime":1607528080450,"results":"17","hashOfConfig":"18"},{"size":362,"mtime":1607527606135,"results":"19","hashOfConfig":"18"},{"size":1655,"mtime":1637621051526,"results":"20","hashOfConfig":"18"},{"size":300,"mtime":1603314346663,"results":"21","hashOfConfig":"18"},{"size":3105,"mtime":1637611534477,"results":"22","hashOfConfig":"18"},{"size":586,"mtime":1603317234163,"results":"23","hashOfConfig":"18"},{"size":2942,"mtime":1638472538933,"results":"24","hashOfConfig":"18"},{"size":3527,"mtime":1637613699101,"results":"25","hashOfConfig":"18"},{"size":1765,"mtime":1603557141468,"results":"26","hashOfConfig":"18"},{"size":7135,"mtime":1637614972865,"results":"27","hashOfConfig":"18"},{"size":1173,"mtime":1603557116927,"results":"28","hashOfConfig":"18"},{"size":1571,"mtime":1607528291867,"results":"29","hashOfConfig":"18"},{"size":2576,"mtime":1637571836244,"results":"30","hashOfConfig":"31"},{"size":837,"mtime":1637533545227,"results":"32","hashOfConfig":"18"},{"size":958,"mtime":1637530841442,"results":"33","hashOfConfig":"18"},{"size":7244,"mtime":1637532339820,"results":"34","hashOfConfig":"18"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},"1bjwq5v",{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"37"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"37"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"37"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"37"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"37"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"68"},"1oykbky",{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"37"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"37"},"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/index.js",[],["77","78"],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/reportWebVitals.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/App.js",["79","80","81","82"],"import React, { useState } from 'react';\n\nimport './assets/reset.css';\nimport './assets/general.css';\n\nimport './features/TodoList/todos.css';\nimport AddTodoForm from './features/TodoList/TodoList/AddTodoForm';\nimport TodoList from './features/TodoList/TodoList/TodoList';\nimport Footer from './features/TodoList/Filter/Footer';\n//import InlineEdit from './components/InlineEdit/InlineEdit';\nimport axios from 'axios';\n\nfunction App() {\n\t\n\tconst [storedHeading, setStoredHeading] = useState(\n\t\t\"Click here to start editing the text!\"\n\t);\n\tconst [storedText, setStoredText] = useState(\"Here's some more, edit away!\");\n\t\n\tconst logout = async () => {\n\t\tconst res = await axios.get('/logout');\n\t\tconsole.log('logout res', res);\n\t\tsetTimeout(() => window.location.replace(\"http://localhost:3000/connexion\"), 5000);\n\t};\n\t\n\treturn (\n\t\t/*<Grid />*/\n\t\t<>\n\t\t\t{/*<Header/>\n\t\t\t <Cards/>\n\t\t\t <Accordion\n\t\t\t title=\"1er volet\"\n\t\t\t >\n\t\t\t <p>Ceci est le 1er paragraphe de l'accordion. Il parle du Lion que voici :</p>\n\t\t\t <p>Le Lion est un spécimène très rare et recherché de nos jours. On l'aime pour ses poils doux et velus.</p>\n\t\t\t </Accordion>\n\t\t\t <div className=\"todos\">\n\t\t\t <AddTodoForm/>\n\t\t\t <TodoList/>\n\t\t\t <Footer/>\n\t\t\t </div>*/}\n\t\t\t<div className=\"todos\">\n\t\t\t\t{/*<h2>\n\t\t\t\t\t Not editable right here.{\" \"}\n\t\t\t\t\t<InlineEdit\n\t\t\t\t\t\ttext={storedHeading}\n\t\t\t\t\t\tonSetText={text => setStoredHeading(text)}\n\t\t\t\t\t/>\n\t\t\t\t</h2>\n\t\t\t\t<p>\n\t\t\t\t\t<InlineEdit text={storedText} onSetText={text => setStoredText(text)} />\n\t\t\t\t</p>*/}\n\t\t\t\t<button onClick={() => logout()}>Logout</button>\n\t\t\t\t<AddTodoForm/>\n\t\t\t\t<TodoList/>\n\t\t\t\t<Footer/>\n\t\t\t</div>\n\t\t</>\n\t);\n}\n\nexport default App;","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/App/store.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoSlice.js",["83"],"import { createSelector, createSlice } from '@reduxjs/toolkit';\n//import { createSelector } from 'reselect';\n\nimport { VisibilityFilters } from '../Filter/FilterSlice';\n\nlet nextTodoId = 0;\n\nconst TodoSlice = createSlice({\n\tname: 'todos',\n\t// TODO : Voir comment gérer le initState ? Si objet, bug car push (addTodo) ne fonctionne pas et todos récupérés\n\t//  dans TodoList (useSelector(selectVisibleTodos) bug car todos = objet\n\tinitialState: /*{\n\t\tid: '',\n\t\ttext: '',\n\t\tcreatedOn: '',\n\t\tcompleted: undefined,\n\t}*/\n\t[],\n\treducers: {\n\t\t/*\n\t\t* TODO : addTodo est avec reducer / prepare ici car on créer l'ID ici même. Ne serait pas comme ça si dans DB\n\t\t* */\n\t\t//addTodo:/*(state, action)*/ {\n\t\t//\treducer(state, action) {\n\t\t//\t\tconst { id, text } = action.payload;\n\t\t//\t\tstate.push({ id, text, completed: false });\n\t\t//\t},\n\t\t//\tprepare(text, id) {\n\t\t//\t\treturn { payload: { text, id/*: nextTodoId++*/ }};\n\t\t//\t}\n\t\t//},\n\t\t// TODO : Voir si ID de la DB est bien récupéré et inséré dans Redux (pour pouvoir modifier un todo sans refresh)\n\t\taddTodo(state, action) {\n\t\t\tconst { id, text } = action.payload;\n\t\t\tconsole.log('redux ID', id);\n\t\t\tstate.push({ id, text, completed: false });\n\t\t},\n\t\taddTodosFromDB(state, action) {\n\t\t\tlet { id, title, status } = action.payload;\n\t\t\t\n\t\t\tstatus = status === 'fait';\n\t\t\t\n\t\t\tstate.push({ id, text: title, completed: status });\n\t\t},\n\t\ttoggleTodo(state, action) {\n\t\t\tconst todo = state.find(todo => todo.id === action.payload);\n\t\t\t\n\t\t\tif (todo) {\n\t\t\t\ttodo.completed = !todo.completed;\n\t\t\t}\n\t\t},\n\t\ttoggleAllTodos(state, action) {\n\t\t\tconst doneTodos = state.every(todo => todo.completed);\n\n\t\t\tstate.map(todo => todo.completed = !doneTodos);\n\t\t},\n\t\teditTodo(state, action) {\n\t\t\tconst todo = state.find(todo => todo.id === action.payload.id);\n\n\t\t\tif (todo) {\n\t\t\t\ttodo.text = action.payload.text;\n\t\t\t}\n\t\t},\n\t\tremoveTodo(state, action) {\n\t\t\t//const todo = state.find(todo => todo.id === action.payload);\n\t\t\t//console.log('DEL TODO PAY', action.payload);\n\t\t\t//if (todo) {\n\t\t\t//\tdelete state[action.payload]//state.id[action.payload];\n\t\t\t//}\n\t\t\t// TODO : Pourquoi utiliser un return ici ? On ne renvoit pas de valeur ?\n\t\t\treturn state.filter(todo => todo.id !== action.payload);\n\t\t}\n\t},\n});\n\nconst selectTodos = state => state.todos;\nconst selectFilters = state => state.filters;\n\nexport const selectVisibleTodos = createSelector(\n\t[selectTodos, selectFilters],\n\t(todos, filter) => {\n\t\tswitch (filter) {\n\t\t\tcase VisibilityFilters.SHOW_ALL:\n\t\t\t\treturn todos;\n\t\t\tcase VisibilityFilters.SHOW_ACTIVE:\n\t\t\t\treturn todos.filter(todo => !todo.completed);\n\t\t\tcase VisibilityFilters.SHOW_COMPLETED:\n\t\t\t\treturn todos.filter(todo => todo.completed);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown filter : ${filter}`);\n\t\t}\n\t}\n);\n\n// TODO : Voir utilité du createSelector ?\nexport const selectUndoneTodosNumber = createSelector(\n\t[selectTodos],\n\t(todos) => {\n\t\treturn todos.filter(todo => !todo.completed).length;\n\t}\n);\n\nconst { actions, reducer } = TodoSlice;\n\nexport const { addTodo, addTodosFromDB, toggleTodo, toggleAllTodos, editTodo, removeTodo } = actions;\n\nexport default reducer;","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/Filter/FilterSlice.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/AddTodoForm.js",["84"],"import React, { useState } from 'react';\n//import PropTypes from 'prop-types';\nimport axios from 'axios';\n\nimport './AddTodoForm.css';\nimport { useDispatch } from 'react-redux';\nimport { addTodo, toggleAllTodos } from './TodoSlice';\n// TODO : Voir si on peut import showAlert du bundle.js (back) depuis le build React pour afficher les erreurs \"générales\" et pas celles du projet séparé ?\n//import { showAlert } from '../../public/js/todos.js';\n\n// TODO : Pourquoi render 2 par 2 ? Comment diminuer le nombre de render ?\n//let render=0;\nconst AddTodoForm = () => {\n\t//render++;console.log('RENDER', render);\n\t\n\tconst [todo, setTodo] = useState('');\n\t\n\tconst dispatch = useDispatch();\n\t\n\t// FIXME : Pourquoi ici POST /todos est tapé sans utiliser axios ? (donc todo entré en DB). Si on utilise axios, provoque un doublon en DB ? => Parce qu'on utilise axios depuis \"le back\" (bundle.js)\n\tfunction submitTodo(e) {\n\t\te.preventDefault();\n\t\t\n\t\tif (!todo.trim()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdispatch(addTodo(todo.trim()));\n\t\t\n\t\tsetTodo('');\n\t}\n\t\n\t// TODO : Car ID retourné depuis DB et utilisé dans Redux, on ne pourra pas utiliser en mode \"invité\"\n\t//  => Créer une autre Fn qui, si on n'est pas connecté, fait seulement submitTodo() sans le backend (et qui utilise l'ancienne Fn Redux qui créer l'ID sur le tas)\n\tasync function submitBackend(e) {\n\t\te.preventDefault();\n\t\t\n\t\tif (!todo.trim())\n\t\t\treturn;\n\t\t\n\t\ttry {\n\t\t\tconst response = await axios.post('http://localhost:3000/todos', {\n\t\t\t\ttitle: todo.trim(),\n\t\t\t\tcompleted: todo.completed,\n\t\t\t\t// TODO : Si todo.completed => status = \"fait\", sinon \"non\". Si \"fait\" => Faire done_on = date.now()\n\t\t\t});\n\t\t\t\n\t\t\tif (response.data.status === 'success' || response.status === 201) {\n\t\t\t\tconsole.log('res id', response.data.id);\n\t\t\t\tdispatch(addTodo({ text: todo.trim(), id: response.data.id }));\n\n\t\t\t\tsetTodo('');\n\t\t\t\t// TODO : dispatch et setTodo() ici ? Comment faire showAlert ici ? (celui du back)\n\t\t\t}\n\t\t\tconsole.log('res',response);\n\t\t}\n\t\t// TODO : Comment gérer l'err dans \"alerts\" (js back) depuis le build React ?\n\t\tcatch (err) {\n\t\t\tif (err.response) {\n\t\t\t\tconsole.log('ERR.RES', err.response);\n\t\t\t}\n\t\t\tconsole.error('ERROR SUBMIT TODO BACKEND : ', err);\n\t\t}\n\t}\n\t\n\treturn (\n\t\t<div className=\"todos-header\">\n\t\t\t<button \n\t\t\t\tclassName=\"toggle-all-todos\"\n\t\t\t\tonClick={() => dispatch(toggleAllTodos())}\n\t\t\t>❯</button>\n\t\t\t<form\n\t\t\t\t// TODO : Revoir les champs controlés (besoin que de onChange et name ? Value aussi non ?)\n\t\t\t\tonSubmit={(e) => submitBackend(e)}\n\t\t\t\tid=\"add-todo-form\"\n\t\t\t\tclassName=\"add-todo-form\"\n\t\t\t>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tplaceholder=\"Ajouter une chose à faire\"\n\t\t\t\t\tid=\"add-todo-input\"\n\t\t\t\t\tclassName=\"add-todo-input\"\n\t\t\t\t\tname=\"todo\"\n\t\t\t\t\tonChange={e => setTodo(e.target.value)}\n\t\t\t\t\tvalue={todo} // TODO : value=todo ?\n\t\t\t\t/>\n\t\t\t\t{/*<button\n\t\t\t\t type=\"submit\"\n\t\t\t\t >\n\t\t\t\t Ajouter\n\t\t\t\t </button>*/}\n\t\t\t</form>\n\t\t</div>\n\t);\n};\n\nexport default AddTodoForm;","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoList.js",["85","86","87","88","89","90"],"import React, { useCallback, useEffect, useRef, useState } from 'react';\n\nimport './TodoList.css';\nimport TodoItempp from './TodoItempp';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { addTodo, addTodosFromDB, editTodo, selectVisibleTodos } from './TodoSlice';\n\nimport axios from 'axios';\nimport TodoItem from './TodoItem';\n\n/*\n* TODO : Général :\n*  => Centrer le tout et mettre un max-width ?\n*  => Rendre responsive\n*  => Styliser le tout\n*\n* TODO : AddTodo.js :\n*  => Ajouter un bouton \"Marquer tout comme fait\" (Redux => toggleAll)\n*\n* TODO : TodoList.js :\n*  => Modifier le onClick (Item.js) => Ne pas déclarer comme \"done\" au click\n*   => Ajouter une checkbox pour mettre un item en \"done\"\n*     => Styliser la checkbox (image ? css => .checkbox:cheked + label => Mettre le text de l'item en tant que label ?)\n*  => Ajouter \"Edit item\" (ouvre un input au lieu de l'item, avec son text déjà dedans) pour éditer un item\n*   => Fait mais utilise onBlur ou enter pour valider. Si on edit un item et qu'on ne va pas dans l'input, l'input\n*  ne s'enlève pas (étant donné qu'il faut passer dedans puis dehors pour le retirer)\n* */\n//let todos;\n\nconst TodoList = () => {\n\tconst dispatch = useDispatch();\n\tlet todos = useSelector(selectVisibleTodos);\n\t//const [todoss, setTodoss] = useState([]);\n\t\n\t/*useEffect(() => {\n\t\t(async () => {\n\t\t\t//let response= await fetchData(\"https://api.coindesk.com/v1/bpi/currentprice.json\");\n\t\t\t//setData(response);\n\t\t\ttry {\n\t\t\t\tconst res = await axios.get('http://localhost:3000/todos');\n\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\t//setTodos(res.data.todoss);\n\t\t\t\t\ttodos = res.data.todos;\n\t\t\t\t\treturn res.data.todos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tconsole.error('ERR GETDBTODOS', err);\n\t\t\t}\n\t\t\t\n\t\t})();\n\t}, []);*/\n\t\n\tconst getDBTodos = async () => {\n\t\ttry {\n\t\t\tconst res = await axios.get('http://localhost:3000/todos');\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\ttodos = res.data.todos;\n\t\t\t\t// TODO : Dispatch tous les todos d'un coup au lieu de loop un à un\n\t\t\t\tfor (let i in todos) {\n\t\t\t\t\tdispatch(addTodosFromDB(todos[i]));\n\t\t\t\t}\n\t\t\t\t//return res.data.todos;\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('ERR GETDBTODOS', err);\n\t\t}\n\t};\n\t\n\t// TODO : Utilise useCallback() ici ?\n\t//const getDb = useCallback(async () => {\n\t//\ttry {\n\t//\t\tconst res = await axios.get('http://localhost:3000/todos');\n\t//\t\tif (res.status === 200 || res.data.status === 'success') {\n\t//\t\t\ttodos = res.data.todos;\n\t//\t\t\t// TODO : Dispatch tous les todos d'un coup au lieu de loop un à un\n\t//\t\t\tfor (let i in todos) {\n\t//\t\t\t\tdispatch(addTodosFromDB(todos[i]));\n\t//\t\t\t}\n\t//\t\t\t//return res.data.todos;\n\t//\t\t}\n\t//\t}\n\t//\tcatch (err) {\n\t//\t\tconsole.error('ERR GETDBTODOS', err);\n\t//\t}\n\t//}, []);\n\t\n\tuseEffect(() => {\n\t\tgetDBTodos();\n\t}, []);\n\t\n\t// TODO : Comment passer cette Fn dans TodoItem ? Impossible ?\n\tconst modifyTodo = (id, newTitle) => {\n\t\tfor (let todo of todos) {\n\t\t\tif (todo.id === id && todo.text !== newTitle) {\n\t\t\t\tdispatch(editTodo({ id, text: newTitle }));\n\t\t\t}\n\t\t}\n\t};\n\t\n\tconst newTodo = (todo) => {\n\t\treturn (\n\t\t\t<TodoItem\n\t\t\t\tkey={todo.id}\n\t\t\t\tid={todo.id}\n\t\t\t\ttext={todo.text}\n\t\t\t\tonEditingTodo={(id, text) => modifyTodo(id, text)}\n\t\t\t\ttodo={todo}\n\t\t\t/>\n\t\t);\n\t};\n\t\n\treturn (\n\t\t<div className=\"todolist-container\">\n\t\t\t<ul className=\"todo-list\">\n\t\t\t\t{/*{\n\t\t\t\t\ttodos.map(todo => (\n\t\t\t\t\t\t<TodoItem key={todo.id} todo={todo} />\n\t\t\t\t\t))\n\t\t\t\t}*/}\n\t\t\t\t{\n\t\t\t\t\ttodos.map(newTodo)\n\t\t\t\t}\n\t\t\t</ul>\n\t\t</div>\n\t);\n};\n\nexport default TodoList;","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/Filter/Footer.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoItem.js",["91","92","93","94","95"],"import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\n\n//import styles from './TodoItem.module.css';\nimport './TodoItem.css';\nimport { useDispatch } from 'react-redux';\nimport { editTodo, removeTodo, toggleTodo } from './TodoSlice';\nimport CustomCheckbox from '../../../components/CustomCheckbox/CustomCheckbox';\nimport axios from 'axios';\nimport useKeyPress from '../../../hooks/useKeyPress';\nimport useOnClickOutside from '../../../hooks/useOnClickOutside';\n//import './InlineEdit.css';\n\n// TODO : Voir si mieux de passer \"text\" en props ou le chercher via un sélecteur ? VOIR POUR ID => id étant ds une func\n/*\n* TODO :\n*  => Faire en sorte que l'input (en mode editing) prenne tout le li sans rien faire bouger\n* */\n// TODO : Unifier Redux et API (completed = true / false au front et \"fait\" / \"non\" au back. Text au front et title au back pour le titre,…)\nconst TodoItem = ({ id, text, todo, onEditingTodo }) => {\n\tconst dispatch = useDispatch();\n\n\tconst [isEditingActive, setIsEditingActive] = useState(false);\n\tconst [editingValue, setEditingValue] = useState(text);\n\t\n\tconst wrapperRef = useRef(null);\n\tconst inputRef = useRef(null);\n\t\n\tconst enter = useKeyPress('Enter');\n\tconst escape = useKeyPress('Escape');\n\t\n\tuseOnClickOutside(wrapperRef, () => {\n\t\tif (isEditingActive) {\n\t\t\tif (editingValue.trim() !== todo.text) {\n\t\t\t\tonEditingTodo(id, editingValue.trim());\n\t\t\t\tedit2(editingValue.trim());\n\t\t\t}\n\t\t\tsetIsEditingActive(false);\n\t\t}\n\t});\n\t\n\tconst onEnter = useCallback(() => {\n\t\tif (enter) {\n\t\t\tif (editingValue.trim() !== todo.text) {\n\t\t\t\tonEditingTodo(id, editingValue.trim());\n\t\t\t\tedit2(editingValue.trim());\n\t\t\t}\n\t\t\tsetIsEditingActive(false);\n\t\t}\n\t}, [enter, editingValue, onEditingTodo]);\n\t\n\tconst onEscape = useCallback(() => {\n\t\tif (escape) {\n\t\t\tsetEditingValue(text);\n\t\t\tsetIsEditingActive(false)\n\t\t}\n\t}, [escape, editingValue, onEditingTodo]);\n\t\n\tuseEffect(() => {\n\t\tif (isEditingActive)\n\t\t\tinputRef.current.focus();\n\t}, [isEditingActive]);\n\t\n\tuseEffect(() => {\n\t\tif (isEditingActive) {\n\t\t\tonEnter();\n\t\t\tonEscape();\n\t\t}\n\t}, [onEnter, onEscape, isEditingActive]);\n\t\n\tconst handleTodoDblClick = useCallback(() => setIsEditingActive(true),\n\t\t[setIsEditingActive]\n\t);\n\t\n\t// TODO : Y'a t'il un intérêt à utiliser useCallback ici ? Permet de ne pas avoir le warning \"promise not used\" mais à part ça ?\n\tconst edit2 = useCallback(async (newTodoText) => {\n\t\ttry {\n\t\t\tif (newTodoText.length === 0) {\n\t\t\t\t// TODO : Utiliser obj config pour l'ID du todo ?\n\t\t\t\t// TODO : Utiliser config authorizationToken ?\n\t\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\t\n\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\t\ttitle: newTodoText.trim()\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// TODO : Utilité de ce code ? Afficher message de succès ? Sinon inutile\n\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\tconsole.log('edit success', res.data);\n\t\t\t\t\t//dispatch(editTodo({ id: todo.id, text: newTodoText.trim() }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\t// TODO : Comment afficher erreur avec alerte \"générale\" ?\n\t\t\t// TODO : Faire 2 try / catch pour catch err si suppr ou si edit ? Ou un seul pour les 2 est bon ?\n\t\t\tconsole.error('Err edit todo', err);\n\t\t}\n\t}, []);\n\t\n\t\n\t// TODO : trim() ne fonctionne pas (on peut ajouter un espace à la fin ou début du todo en editant)\n\tconst edit = async () => {\n\t\tconst newTodoText = editingValue.trim();\n\t\t\n\t\ttry {\n\t\t\tif (newTodoText.length === 0) {\n\t\t\t\t// TODO : Utiliser obj config pour l'ID du todo ?\n\t\t\t\t// TODO : Utiliser config authorizationToken ?\n\t\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\t\n\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\t\ttitle: newTodoText.trim()\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// TODO : Utilité de ce code ? Afficher message de succès ? Sinon inutile\n\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\tconsole.log('edit success', res.data);\n\t\t\t\t\t//dispatch(editTodo({ id: todo.id, text: newTodoText.trim() }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\t// TODO : Comment afficher erreur avec alerte \"générale\" ?\n\t\t\t// TODO : Faire 2 try / catch pour catch err si suppr ou si edit ? Ou un seul pour les 2 est bon ?\n\t\t\tconsole.error('Err edit todo', err);\n\t\t}\n\t};\n\t\n\tconst deleteTodo = async () => {\n\t\ttry {\n\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Err deleteTodo', err);\n\t\t}\n\t};\n\t\n\t// TODO : Modifier la date \"done_on\" si on passe le status à \"fait\" et le suppr si on passe à \"non\"\n\tconst changeTodoStatus = async () => {\n\t\ttry {\n\t\t\tconst status = todo.completed ? 'non': 'fait';\n\t\t\tlet done_on;\n\t\t\t\n\t\t\t// TODO : Fixer la date pour avoir la bonne du client (ici on a -1h avec new Date())\n\t\t\tif (status === 'fait') done_on = new Date();\n\t\t\telse done_on = null;\n\t\t\t\n\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\tstatus,\n\t\t\t\tdone_on\n\t\t\t});\n\t\t\t\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\tdispatch(toggleTodo(todo.id));\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Err changeTodoStatus', err);\n\t\t}\n\t};\n\t\n\t\n\t// TODO : Quand on sort de isEditing, le .checked de checkbox disparait mais le style du li reste (= done)\n\t// TODO : Si todo.completed : ajouter .checked sur CustomCheckbox\n\treturn (\n\t\t<li\n\t\t\tref={wrapperRef}\n\t\t\t// TODO : Si un todo n'est pas class .done, il ne peut pas être checked dans CustomCheckbox\n\t\t\tclassName={clsx('todo-item', { 'done': todo.completed }, { 'editing': isEditingActive })}\n\t\t>\n\t\t\t<CustomCheckbox\n\t\t\t\tonClick={() => changeTodoStatus()}\n\t\t\t\tdone={todo.completed}\n\t\t\t/>\n\t\t\t<label\n\t\t\t\t// TODO : Revoir le css du label ?\n\t\t\t\tonDoubleClick={handleTodoDblClick}\n\t\t\t\tclassName={`inline-text_copy inline-text_copy--${\n\t\t\t\t\t!isEditingActive ? \"active\" : \"hidden\"\n\t\t\t\t}`}\n\t\t\t>{\n\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\ttodo.text\n\t\t\t}</label>\n\t\t\t<input\n\t\t\t\tref={inputRef}\n\t\t\t\tvalue={editingValue}\n\t\t\t\t// TODO : Voir pourquoi on utilise pas la syntaxe normale : (e) => setIsEditingValue(e.target.value)\n\t\t\t\tonChange={e => setEditingValue(e.target.value)}\n\t\t\t\tclassName={`inline-text_input inline-text_input--${\n\t\t\t\t\tisEditingActive ? \"active\" : \"hidden\"\n\t\t\t\t}`}\n\t\t\t/>\n\t\t\t<button\n\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\tonClick={() => deleteTodo()}\n\t\t\t>\n\t\t\t\t&times;\n\t\t\t</button>\n\t\t</li>\n\t);\n};\n\nTodoItem.propTypes = {\n\ttodo: PropTypes.shape({\n\t\tid: PropTypes.number.isRequired,\n\t\ttext: PropTypes.string.isRequired,\n\t\tcompleted: PropTypes.bool.isRequired\n\t}).isRequired\n};\n\nexport default TodoItem;","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/Filter/FilterLink.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/components/CustomCheckbox/CustomCheckbox.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/components/InlineEdit/InlineEdit.js",["96"],"import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport useKeyPress from '../../hooks/useKeyPress';\nimport useOnClickOutside from '../../hooks/useOnClickOutside';\n\nimport './InlineEdit.css';\n\nfunction InlineEdit(props) {\n\tconst [isInputActive, setIsInputActive] = useState(false);\n\tconst [inputValue, setInputValue] = useState(props.text);\n\t\n\t// Get the wrapping span node\n\tconst wrapperRef = useRef(null);\n\tconst textRef = useRef(null);\n\tconst inputRef = useRef(null);\n\t\n\tconst enter = useKeyPress('Enter');\n\tconst esc = useKeyPress('Escape');\n\t\n\tconst { onSetText } = props;\n\t\n\t// This hook takes a ref to watch and a Fn to run if the click happened outside\n\tuseOnClickOutside(wrapperRef, () => {\n\t\tif (isInputActive) {\n\t\t\t// Save the value and close the editor\n\t\t\tonSetText(inputValue);\n\t\t\tsetIsInputActive(false);\n\t\t}\n\t});\n\t\n\tconst onEnter = useCallback(() => {\n\t\tif (enter) {\n\t\t\tonSetText(inputValue);\n\t\t\tsetIsInputActive(false);\n\t\t}\n\t}, [enter, inputValue, onSetText]);\n\t\n\tconst onEsc = useCallback(() => {\n\t\tif (esc) {\n\t\t\tsetInputValue(props.text);\n\t\t\tsetIsInputActive(false);\n\t\t}\n\t}, [esc, inputValue, onSetText]);\n\t\n\t// Focus the cursor in the input field on edit start\n\tuseEffect(() => {\n\t\tif (isInputActive) {\n\t\t\tinputRef.current.focus();\n\t\t}\n\t}, [isInputActive]);\n\t\n\tuseEffect(() => {\n\t\tif (isInputActive) {\n\t\t\t// if Enter is pressed, save the text and close the editor\n\t\t\tonEnter();\n\t\t\t// if Escape is pressed, revert the text and close the editor\n\t\t\tonEsc();\n\t\t}\n\t}, [onEnter, onEsc, isInputActive]); // Watch the Enter and Escape key presses\n\t\n\t//const handleInputChange = useCallback(\n\t//\tevent => {\n\t//\t\t// sanitize the input a little\n\t//\t\tsetInputValue(DOMPurify.sanitize(event.target.value));\n\t//\t},\n\t//\t[setInputValue]\n\t//);\n\t\n\t\n\tconst handleSpanClick = useCallback(() => setIsInputActive(true),\n\t\t[setIsInputActive]\n\t);\n\t\n\treturn (\n\t\t<span className=\"inline-text\" ref={wrapperRef}>\n\t\t\t<span\n\t\t\t\tref={textRef}\n\t\t\t\tonClick={handleSpanClick}\n\t\t\t\tclassName={`inline-text_copy inline-text_copy--${\n\t\t\t\t\t!isInputActive ? \"active\" : \"hidden\"\n\t\t\t\t}`}\n\t\t\t>\n\t\t\t\t{ props.text }\n\t\t\t</span>\n\t\t\t\n\t\t\t<input\n\t\t\t\tref={inputRef}\n\t\t\t\t// set the width to the input length multiplied by the x height\n\t\t\t\t// it's not quite right but gets it close\n\t\t\t\tstyle={{ width: Math.ceil(inputValue.length * 0.9) + \"ex\" }}\n\t\t\t\tvalue={inputValue}\n\t\t\t\tonChange={e => {\n\t\t\t\t\tsetInputValue(e.target.value);\n\t\t\t\t}}\n\t\t\t\tclassName={`inline-text_input inline-text_input--${\n\t\t\t\t\tisInputActive ? \"active\" : \"hidden\"\n\t\t\t\t}`}\n\t\t\t/>\n\t\t</span>\n\t);\n}\n\nexport default InlineEdit;",["97","98"],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/hooks/useKeyPress.js",["99"],"import { useState, useEffect } from 'react';\n\nfunction useKeyPress(targetKey) {\n\t// State for keeping track of which key is pressed\n\tconst [keyPressed, setKeyPressed] = useState(false);\n\t\n\t// If pressed key is our target key then set to true\n\tfunction downHandler({ key }) {\n\t\tif (key === targetKey) setKeyPressed(true);\n\t}\n\t\n\t// If released key is our target key then set to false\n\tconst upHandler = ({ key }) => {\n\t\tif (key === targetKey) setKeyPressed(false);\n\t};\n\t\n\t// Add event listeners\n\tuseEffect(() => {\n\t\twindow.addEventListener('keydown', downHandler);\n\t\twindow.addEventListener('keyup', upHandler);\n\t\t// Remove event listeners on cleanup\n\t\treturn () => {\n\t\t\twindow.removeEventListener('keydown', downHandler);\n\t\t\twindow.removeEventListener('keyup', upHandler);\n\t\t}\n\t}, []);\n\t\n\treturn keyPressed;\n}\n\nexport default useKeyPress;","/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/hooks/useOnClickOutside.js",[],"/Users/tompomarede/Documents/PROJETS_CV_PORTFOLIO/todo_app_finale/todo_v2/client/src/features/TodoList/TodoList/TodoItempp.js",["100"],"import React, { useState } from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\n\n//import styles from './TodoItem.module.css';\nimport './TodoItem.css';\nimport { useDispatch } from 'react-redux';\nimport { editTodo, removeTodo, toggleTodo } from './TodoSlice';\nimport CustomCheckbox from '../../../components/CustomCheckbox/CustomCheckbox';\nimport axios from 'axios';\n\n// TODO : Voir si mieux de passer \"text\" en props ou le chercher via un sélecteur ? VOIR POUR ID => id étant ds une func\n/*\n* TODO :\n*  => Faire en sorte que l'input (en mode editing) prenne tout le li sans rien faire bouger\n* */\n// TODO : Unifier Redux et API (completed = true / false au front et \"fait\" / \"non\" au back. Text au front et title au back pour le titre,…)\nconst TodoItempp = ({ id, text, /*edit,*/ todo }) => {\n\tconst dispatch = useDispatch();\n\t\n\t/*const onInputChange = (e) => {\n\t\tconst newValue = e.target.value;\n\t\tedit(id, newValue);\n\t};*/\n\t\n\t/*return (\n\t\t<li\n\t\t\t// TODO : Si un todo n'est pas class .done, il ne peut pas être checked dans CustomCheckbox\n\t\t\tclassName={clsx('todo-item', { 'done': todo.completed })}\n\t\t\t//onClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\t// TODO : Si on utilise <label> pour le texte de l'item, placer le onDblClick sur label ?\n\t\t\t//onDoubleClick={() => setIsEditing(true)}\n\t\t>\n\t\t\t<CustomCheckbox\n\t\t\t\tonClick={() => changeTodoStatus()}\n\t\t\t\tdone={todo.completed}\n\t\t\t/>\n\t\t\t<label\n\t\t\t\t// TODO : Revoir le css du label ?\n\t\t\t\tonDoubleClick={() => setIsEditing(true)}\n\t\t\t>{\n\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\ttodo.text\n\t\t\t}</label>\n\t\t\t<button\n\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\tonClick={() => deleteTodo()}\n\t\t\t>\n\t\t\t\t&times;\n\t\t\t</button>\n\t\t</li>\n\t)*/\n\t\n\tconst [isEditing, setIsEditing] = useState(false);\n\tconst [isEditingValue, setIsEditingValue] = useState(todo.text);\n\t\n\t/*const edit = (e) => {\n\t\tconst newTodoText = isEditingValue.trim();\n\t\tif (isEditing) {\n\t\t\t// TODO : Voir si on utiliser e.nativeEvent.type est dangereux ?\n\t\t\tif (e.which === 13 || e.nativeEvent.type === 'blur') {\n\t\t\t\tif (newTodoText.length === 0) {\n\t\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdispatch(editTodo({ id: todo.id, text: newTodoText }));\n\t\t\t\t}\n\t\t\t\t//dispatch(editTodo(todo.id));\n\t\t\t\tsetIsEditing(false);\n\t\t\t}\n\t\t}\n\t};*/\n\t\n\t// TODO : trim() ne fonctionne pas (on peut ajouter un espace à la fin ou début du todo en editant)\n\tconst edit = async (e) => {\n\t\tconst newTodoText = isEditingValue.trim();\n\t\t\n\t\tif (isEditing) {\n\t\t\ttry {\n\t\t\t\tif (e.which === 13 || e.nativeEvent.type === 'blur') {\n\t\t\t\t\tif (newTodoText.length === 0) {\n\t\t\t\t\t\t// TODO : Utiliser obj config pour l'ID du todo ?\n\t\t\t\t\t\t// TODO : Utiliser config authorizationToken ?\n\t\t\t\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\t\t\tconsole.log('removed success', res.data);\n\t\t\t\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\t\t\t\ttitle: newTodoText.trim()\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\t\t\tconsole.log('edit success', res.data);\n\t\t\t\t\t\t\tdispatch(editTodo({ id: todo.id, text: newTodoText.trim() }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsetIsEditing(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\t// TODO : Comment afficher erreur avec alerte \"générale\" ?\n\t\t\t\t// TODO : Faire 2 try / catch pour catch err si suppr ou si edit ? Ou un seul pour les 2 est bon ?\n\t\t\t\tconsole.error('Err edit todo', err);\n\t\t\t}\n\t\t\t// TODO : Voir si on utiliser e.nativeEvent.type est dangereux ?\n\t\t}\n\t};\n\t\n\tconst deleteTodo = async () => {\n\t\ttry {\n\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Err deleteTodo', err);\n\t\t}\n\t};\n\t\n\t// TODO : Modifier la date \"done_on\" si on passe le status à \"fait\" et le suppr si on passe à \"non\"\n\tconst changeTodoStatus = async () => {\n\t\ttry {\n\t\t\tconst status = todo.completed ? 'non': 'fait';\n\t\t\tlet done_on;\n\t\t\t\n\t\t\t// TODO : Fixer la date pour avoir la bonne du client (ici on a -1h avec new Date())\n\t\t\tif (status === 'fait') done_on = new Date();\n\t\t\telse done_on = null;\n\t\t\t\n\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\tstatus,\n\t\t\t\tdone_on\n\t\t\t});\n\t\t\t\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\tdispatch(toggleTodo(todo.id));\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Err changeTodoStatus', err);\n\t\t}\n\t};\n\t\n\tconst editingInput = () => {\n\t\n\t};\n\t\n\t// TODO : Quand on sort de isEditing, le .checked de checkbox disparait mais le style du li reste (= done)\n\tif (isEditing) {\n\t\treturn (\n\t\t\t<li\n\t\t\t\tclassName={clsx('todo-item', 'editing')}\n\t\t\t\t//onClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\t>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue={isEditingValue}\n\t\t\t\t\tonChange={e => setIsEditingValue(e.target.value)}\n\t\t\t\t\tonBlur={e => edit(e)}\n\t\t\t\t\t// TODO : Changer le outline du :focus (background-color ?)\n\t\t\t\t\tautoFocus={true}\n\t\t\t\t\tonKeyDown={e => edit(e)}\n\t\t\t\t/>\n\t\t\t</li>\n\t\t)\n\t}\n\telse {\n\t\t// TODO : Si todo.completed : ajouter .checked sur CustomCheckbox\n\t\treturn (\n\t\t\t<li\n\t\t\t\t// TODO : Si un todo n'est pas class .done, il ne peut pas être checked dans CustomCheckbox\n\t\t\t\tclassName={clsx('todo-item', { 'done': todo.completed })}\n\t\t\t\t//onClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\t\t// TODO : Si on utilise <label> pour le texte de l'item, placer le onDblClick sur label ?\n\t\t\t\t//onDoubleClick={() => setIsEditing(true)}\n\t\t\t>\n\t\t\t\t<CustomCheckbox\n\t\t\t\t\tonClick={() => changeTodoStatus()}\n\t\t\t\t\tdone={todo.completed}\n\t\t\t\t/>\n\t\t\t\t<label\n\t\t\t\t\t// TODO : Revoir le css du label ?\n\t\t\t\t\tonDoubleClick={() => setIsEditing(true)}\n\t\t\t\t>{\n\t\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\t\ttodo.text\n\t\t\t\t}</label>\n\t\t\t\t<button\n\t\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\t\tonClick={() => deleteTodo()}\n\t\t\t\t>\n\t\t\t\t\t&times;\n\t\t\t\t</button>\n\t\t\t</li>\n\t\t)\n\t}\n\t\n\t/*return (\n\t\t<li\n\t\t\tclassName={clsx('todo-item', { 'done': todo.completed })}\n\t\t\tonClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\tonDoubleClick={() => setIsEditing(true)}\n\t\t>\n\t\t\t{\n\t\t\t\tisEditing &&\n\t\t\t\t<input type=\"text\" value={todo.text} onChange={e => setIsEditingValue(e.target.value)} />\n\t\t\t}\n\t\t\t{\n\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\ttodo.text\n\t\t\t}\n\t\t\t<button\n\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\tonClick={() => dispatch(removeTodo(todo.id))}\n\t\t\t\tonDoubleClick={() => doubleClickTodo(todo.id)}\n\t\t\t>\n\t\t\t\t&times;\n\t\t\t</button>\n\t\t</li>\n\t);*/\n};\n\nTodoItempp.propTypes = {\n\ttodo: PropTypes.shape({\n\t\tid: PropTypes.number.isRequired,\n\t\ttext: PropTypes.string.isRequired,\n\t\tcompleted: PropTypes.bool.isRequired\n\t}).isRequired\n};\n\nexport default TodoItempp;",{"ruleId":"101","replacedBy":"102"},{"ruleId":"103","replacedBy":"104"},{"ruleId":"105","severity":1,"message":"106","line":15,"column":9,"nodeType":"107","messageId":"108","endLine":15,"endColumn":22},{"ruleId":"105","severity":1,"message":"109","line":15,"column":24,"nodeType":"107","messageId":"108","endLine":15,"endColumn":40},{"ruleId":"105","severity":1,"message":"110","line":18,"column":9,"nodeType":"107","messageId":"108","endLine":18,"endColumn":19},{"ruleId":"105","severity":1,"message":"111","line":18,"column":21,"nodeType":"107","messageId":"108","endLine":18,"endColumn":34},{"ruleId":"105","severity":1,"message":"112","line":6,"column":5,"nodeType":"107","messageId":"108","endLine":6,"endColumn":15},{"ruleId":"105","severity":1,"message":"113","line":21,"column":11,"nodeType":"107","messageId":"108","endLine":21,"endColumn":21},{"ruleId":"105","severity":1,"message":"114","line":1,"column":17,"nodeType":"107","messageId":"108","endLine":1,"endColumn":28},{"ruleId":"105","severity":1,"message":"115","line":1,"column":41,"nodeType":"107","messageId":"108","endLine":1,"endColumn":47},{"ruleId":"105","severity":1,"message":"116","line":1,"column":49,"nodeType":"107","messageId":"108","endLine":1,"endColumn":57},{"ruleId":"105","severity":1,"message":"117","line":4,"column":8,"nodeType":"107","messageId":"108","endLine":4,"endColumn":18},{"ruleId":"105","severity":1,"message":"118","line":6,"column":10,"nodeType":"107","messageId":"108","endLine":6,"endColumn":17},{"ruleId":"119","severity":1,"message":"120","line":91,"column":5,"nodeType":"121","endLine":91,"endColumn":7,"suggestions":"122"},{"ruleId":"105","severity":1,"message":"123","line":8,"column":10,"nodeType":"107","messageId":"108","endLine":8,"endColumn":18},{"ruleId":"119","severity":1,"message":"124","line":51,"column":5,"nodeType":"121","endLine":51,"endColumn":41,"suggestions":"125"},{"ruleId":"119","severity":1,"message":"126","line":58,"column":5,"nodeType":"121","endLine":58,"endColumn":42,"suggestions":"127"},{"ruleId":"119","severity":1,"message":"128","line":105,"column":5,"nodeType":"121","endLine":105,"endColumn":7,"suggestions":"129"},{"ruleId":"105","severity":1,"message":"130","line":109,"column":8,"nodeType":"107","messageId":"108","endLine":109,"endColumn":12},{"ruleId":"119","severity":1,"message":"131","line":42,"column":5,"nodeType":"121","endLine":42,"endColumn":33,"suggestions":"132"},{"ruleId":"101","replacedBy":"133"},{"ruleId":"103","replacedBy":"134"},{"ruleId":"119","severity":1,"message":"135","line":26,"column":5,"nodeType":"121","endLine":26,"endColumn":7,"suggestions":"136"},{"ruleId":"105","severity":1,"message":"137","line":151,"column":8,"nodeType":"107","messageId":"108","endLine":151,"endColumn":20},"no-native-reassign",["138"],"no-negated-in-lhs",["139"],"no-unused-vars","'storedHeading' is assigned a value but never used.","Identifier","unusedVar","'setStoredHeading' is assigned a value but never used.","'storedText' is assigned a value but never used.","'setStoredText' is assigned a value but never used.","'nextTodoId' is assigned a value but never used.","'submitTodo' is defined but never used.","'useCallback' is defined but never used.","'useRef' is defined but never used.","'useState' is defined but never used.","'TodoItempp' is defined but never used.","'addTodo' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getDBTodos'. Either include it or remove the dependency array.","ArrayExpression",["140"],"'editTodo' is defined but never used.","React Hook useCallback has missing dependencies: 'edit2', 'id', and 'todo.text'. Either include them or remove the dependency array.",["141"],"React Hook useCallback has a missing dependency: 'text'. Either include it or remove the dependency array. If 'setEditingValue' needs the current value of 'text', you can also switch to useReducer instead of useState and read 'text' in the reducer.",["142"],"React Hook useCallback has missing dependencies: 'dispatch' and 'todo.id'. Either include them or remove the dependency array.",["143"],"'edit' is assigned a value but never used.","React Hook useCallback has a missing dependency: 'props.text'. Either include it or remove the dependency array. If 'setInputValue' needs the current value of 'props.text', you can also switch to useReducer instead of useState and read 'props.text' in the reducer.",["144"],["138"],["139"],"React Hook useEffect has missing dependencies: 'downHandler' and 'upHandler'. Either include them or remove the dependency array.",["145"],"'editingInput' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"146","fix":"147"},{"desc":"148","fix":"149"},{"desc":"150","fix":"151"},{"desc":"152","fix":"153"},{"desc":"154","fix":"155"},{"desc":"156","fix":"157"},"Update the dependencies array to be: [getDBTodos]",{"range":"158","text":"159"},"Update the dependencies array to be: [enter, editingValue, todo.text, onEditingTodo, id, edit2]",{"range":"160","text":"161"},"Update the dependencies array to be: [escape, text]",{"range":"162","text":"163"},"Update the dependencies array to be: [dispatch, todo.id]",{"range":"164","text":"165"},"Update the dependencies array to be: [esc, props.text]",{"range":"166","text":"167"},"Update the dependencies array to be: [downHandler, upHandler]",{"range":"168","text":"169"},[2805,2807],"[getDBTodos]",[1747,1783],"[enter, editingValue, todo.text, onEditingTodo, id, edit2]",[1905,1942],"[escape, text]",[3418,3420],"[dispatch, todo.id]",[1116,1144],"[esc, props.text]",[780,782],"[downHandler, upHandler]"]