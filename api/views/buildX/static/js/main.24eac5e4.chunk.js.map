{"version":3,"sources":["features/TodoList/Filter/FilterSlice.js","features/TodoList/TodoList/TodoSlice.js","features/TodoList/TodoList/AddTodoForm.js","components/CustomCheckbox/CustomCheckbox.js","features/TodoList/TodoList/TodoItempp.js","features/TodoList/TodoList/TodoList.js","features/TodoList/Filter/FilterLink.js","features/TodoList/Filter/Footer.js","hooks/useKeyPress.js","hooks/useOnClickOutside.js","components/InlineEdit/InlineEdit.js","App.js","reportWebVitals.js","App/store.js","index.js"],"names":["VisibilityFilters","FilterSlice","createSlice","name","initialState","reducers","setVisibilityFilter","state","action","payload","actions","reducer","TodoSlice","addTodo","id","text","console","log","push","completed","addTodosFromDB","title","status","toggleTodo","todo","find","toggleAllTodos","doneTodos","every","map","editTodo","removeTodo","filter","selectTodos","todos","selectVisibleTodos","createSelector","filters","Error","selectUndoneTodosNumber","length","AddTodoForm","useState","setTodo","dispatch","useDispatch","e","a","preventDefault","trim","axios","post","response","data","error","className","onClick","onSubmit","submitBackend","type","placeholder","onChange","target","value","CustomCheckbox","done","isChecked","setIsChecked","clsx","checked","TodoItempp","isEditing","setIsEditing","isEditingValue","setIsEditingValue","edit","newTodoText","which","nativeEvent","delete","res","put","deleteTodo","changeTodoStatus","done_on","Date","onBlur","autoFocus","onKeyDown","onDoubleClick","TodoList","useSelector","getDBTodos","get","i","useEffect","newTitle","todosCopy","FilterLink","activeFilter","children","Footer","setActiveFilter","undoneTodosNumber","todosLeftWord","toggleFilter","useKeyPress","targetKey","keyPressed","setKeyPressed","downHandler","key","upHandler","window","addEventListener","removeEventListener","useOnClickOutside","ref","handler","listener","event","current","contains","document","InlineEdit","props","isInputActive","setIsInputActive","inputValue","setInputValue","wrapperRef","useRef","textRef","inputRef","enter","esc","onSetText","onEnter","useCallback","onEsc","focus","handleSpanClick","style","width","Math","ceil","App","storedHeading","setStoredHeading","storedText","setStoredText","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","store","configureStore","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.24eac5e4.chunk.js","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n\nexport const VisibilityFilters = {\n\tSHOW_ALL: 'SHOW_ALL',\n\tSHOW_COMPLETED: 'SHOW_COMPLETED',\n\tSHOW_ACTIVE: 'SHOW_ACTIVE'\n};\n\nconst FilterSlice = createSlice({\n\tname: 'filters',\n\tinitialState: VisibilityFilters.SHOW_ALL,\n\treducers: {\n\t\tsetVisibilityFilter(state, action) {\n\t\t\t// TODO : Pourquoi on utiliser return ici ? VOIR LA DOC\n\t\t\treturn action.payload;\n\t\t}\n\t}\n});\n\nexport const selectFilters = state => state.filter;\n\nconst { actions, reducer } = FilterSlice;\n\nexport const { setVisibilityFilter } = actions;\n\nexport default reducer;","import { createSelector, createSlice } from '@reduxjs/toolkit';\n//import { createSelector } from 'reselect';\n\nimport { VisibilityFilters } from '../Filter/FilterSlice';\n\nlet nextTodoId = 0;\n\nconst TodoSlice = createSlice({\n\tname: 'todos',\n\t// TODO : Voir comment gérer le initState ? Si objet, bug car push (addTodo) ne fonctionne pas et todos récupérés\n\t//  dans TodoList (useSelector(selectVisibleTodos) bug car todos = objet\n\tinitialState: /*{\n\t\tid: '',\n\t\ttext: '',\n\t\tcreatedOn: '',\n\t\tcompleted: undefined,\n\t}*/\n\t[],\n\treducers: {\n\t\t/*\n\t\t* TODO : addTodo est avec reducer / prepare ici car on créer l'ID ici même. Ne serait pas comme ça si dans DB\n\t\t* */\n\t\t//addTodo:/*(state, action)*/ {\n\t\t//\treducer(state, action) {\n\t\t//\t\tconst { id, text } = action.payload;\n\t\t//\t\tstate.push({ id, text, completed: false });\n\t\t//\t},\n\t\t//\tprepare(text, id) {\n\t\t//\t\treturn { payload: { text, id/*: nextTodoId++*/ }};\n\t\t//\t}\n\t\t//},\n\t\t// TODO : Voir si ID de la DB est bien récupéré et inséré dans Redux (pour pouvoir modifier un todo sans refresh)\n\t\taddTodo(state, action) {\n\t\t\tconst { id, text } = action.payload;\n\t\t\tconsole.log('redux ID', id);\n\t\t\tstate.push({ id, text, completed: false });\n\t\t},\n\t\taddTodosFromDB(state, action) {\n\t\t\tlet { id, title, status } = action.payload;\n\t\t\t\n\t\t\tstatus = status === 'fait';\n\t\t\t\n\t\t\tstate.push({ id, text: title, completed: status });\n\t\t},\n\t\ttoggleTodo(state, action) {\n\t\t\tconst todo = state.find(todo => todo.id === action.payload);\n\t\t\t\n\t\t\tif (todo) {\n\t\t\t\ttodo.completed = !todo.completed;\n\t\t\t}\n\t\t},\n\t\ttoggleAllTodos(state, action) {\n\t\t\tconst doneTodos = state.every(todo => todo.completed);\n\n\t\t\tstate.map(todo => todo.completed = !doneTodos);\n\t\t},\n\t\teditTodo(state, action) {\n\t\t\tconst todo = state.find(todo => todo.id === action.payload.id);\n\t\t\t\n\t\t\tif (todo) {\n\t\t\t\ttodo.text = action.payload.text;\n\t\t\t}\n\t\t},\n\t\tremoveTodo(state, action) {\n\t\t\t//const todo = state.find(todo => todo.id === action.payload);\n\t\t\t//console.log('DEL TODO PAY', action.payload);\n\t\t\t//if (todo) {\n\t\t\t//\tdelete state[action.payload]//state.id[action.payload];\n\t\t\t//}\n\t\t\t// TODO : Pourquoi utiliser un return ici ? On ne renvoit pas de valeur ?\n\t\t\treturn state.filter(todo => todo.id !== action.payload);\n\t\t}\n\t},\n});\n\nconst selectTodos = state => state.todos;\nconst selectFilters = state => state.filters;\n\nexport const selectVisibleTodos = createSelector(\n\t[selectTodos, selectFilters],\n\t(todos, filter) => {\n\t\tswitch (filter) {\n\t\t\tcase VisibilityFilters.SHOW_ALL:\n\t\t\t\treturn todos;\n\t\t\tcase VisibilityFilters.SHOW_ACTIVE:\n\t\t\t\treturn todos.filter(todo => !todo.completed);\n\t\t\tcase VisibilityFilters.SHOW_COMPLETED:\n\t\t\t\treturn todos.filter(todo => todo.completed);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown filter : ${filter}`);\n\t\t}\n\t}\n);\n\n// TODO : Voir utilité du createSelector ?\nexport const selectUndoneTodosNumber = createSelector(\n\t[selectTodos],\n\t(todos) => {\n\t\treturn todos.filter(todo => !todo.completed).length;\n\t}\n);\n\nconst { actions, reducer } = TodoSlice;\n\nexport const { addTodo, addTodosFromDB, toggleTodo, toggleAllTodos, editTodo, removeTodo } = actions;\n\nexport default reducer;","import React, { useState } from 'react';\n//import PropTypes from 'prop-types';\nimport axios from 'axios';\n\nimport './AddTodoForm.css';\nimport { useDispatch } from 'react-redux';\nimport { addTodo, toggleAllTodos } from './TodoSlice';\n// TODO : Voir si on peut import showAlert du bundle.js (back) depuis le build React pour afficher les erreurs \"générales\" et pas celles du projet séparé ?\n//import { showAlert } from '../../public/js/todos.js';\n\n// TODO : Pourquoi render 2 par 2 ? Comment diminuer le nombre de render ?\n//let render=0;\nconst AddTodoForm = () => {\n\t//render++;console.log('RENDER', render);\n\t\n\tconst [todo, setTodo] = useState('');\n\t\n\tconst dispatch = useDispatch();\n\t\n\t// FIXME : Pourquoi ici POST /todos est tapé sans utiliser axios ? (donc todo entré en DB). Si on utilise axios, provoque un doublon en DB ? => Parce qu'on utilise axios depuis \"le back\" (bundle.js)\n\tfunction submitTodo(e) {\n\t\te.preventDefault();\n\t\t\n\t\tif (!todo.trim()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdispatch(addTodo(todo.trim()));\n\t\t\n\t\tsetTodo('');\n\t}\n\t\n\t// TODO : Car ID retourné depuis DB et utilisé dans Redux, on ne pourra pas utiliser en mode \"invité\"\n\t//  => Créer une autre Fn qui, si on n'est pas connecté, fait seulement submitTodo() sans le backend (et qui utilise l'ancienne Fn Redux qui créer l'ID sur le tas)\n\tasync function submitBackend(e) {\n\t\te.preventDefault();\n\t\t\n\t\tif (!todo.trim())\n\t\t\treturn;\n\t\t\n\t\ttry {\n\t\t\tconst response = await axios.post('http://localhost:3000/todos', {\n\t\t\t\ttitle: todo.trim(),\n\t\t\t\tcompleted: todo.completed,\n\t\t\t\t// TODO : Si todo.completed => status = \"fait\", sinon \"non\". Si \"fait\" => Faire done_on = date.now()\n\t\t\t});\n\t\t\t\n\t\t\tif (response.data.status === 'success' || response.status === 201) {\n\t\t\t\tconsole.log('res id', response.data.id);\n\t\t\t\tdispatch(addTodo({ text: todo.trim(), id: response.data.id }));\n\n\t\t\t\tsetTodo('');\n\t\t\t\t// TODO : Comment faire showAlert ici ? (celui du back)\n\t\t\t}\n\t\t\tconsole.log('res',response);\n\t\t}\n\t\t// TODO : Comment gérer l'err dans \"alerts\" (js back) depuis le build React ?\n\t\tcatch (err) {\n\t\t\tconsole.error('ERROR SUBMIT TODO BACKEND : ', err);\n\t\t}\n\t}\n\t\n\treturn (\n\t\t<div className=\"todos-header\">\n\t\t\t<button \n\t\t\t\tclassName=\"toggle-all-todos\"\n\t\t\t\tonClick={() => dispatch(toggleAllTodos())}\n\t\t\t>❯</button>\n\t\t\t<form\n\t\t\t\t// TODO : Revoir les champs controlés (besoin que de onChange et name ? Value aussi non ?)\n\t\t\t\tonSubmit={(e) => submitBackend(e)}\n\t\t\t\tid=\"add-todo-form\"\n\t\t\t\tclassName=\"add-todo-form\"\n\t\t\t>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tplaceholder=\"Ajouter une chose à faire\"\n\t\t\t\t\tid=\"add-todo-input\"\n\t\t\t\t\tclassName=\"add-todo-input\"\n\t\t\t\t\tname=\"todo\"\n\t\t\t\t\tonChange={e => setTodo(e.target.value)}\n\t\t\t\t\tvalue={todo} // TODO : value=todo ?\n\t\t\t\t/>\n\t\t\t\t{/*<button\n\t\t\t\t type=\"submit\"\n\t\t\t\t >\n\t\t\t\t Ajouter\n\t\t\t\t </button>*/}\n\t\t\t</form>\n\t\t</div>\n\t);\n};\n\nexport default AddTodoForm;","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\n\nimport './CustomCheckbox.css';\n\nconst CustomCheckbox = ({ onClick, done }) => {\n\tconst [isChecked, setIsChecked] = useState(false);\n\t\n\t// TODO : Si !done, le checkbox ne peut pas avoir la class .checked\n\t\n\tfunction onChange() {\n\t\tconsole.log('ISCHECKED', isChecked, 'DONE', done)\n\t\t// TODO : Voir un meilleur moyen pour le check ?\n\t\t//  => Pire des cas : isChecked = false et done = true (qd on repasse à undone après un edit sur un done)\n\t\t/*if (!isChecked || !done) {\n\t\t setIsChecked(true);\n\t\t }*/\n\t\t\n\t\t// TODO : Comprendre le fonctionnement ? (en rapport avec toggleAllTodos de TodoSlic  e.js)\n\t\tif (!done) {\n\t\t\tsetIsChecked(false);\n\t\t}\n\t\telse if (done || isChecked) {\n\t\t\tsetIsChecked(false);\n\t\t}\n\t\t/*else if (!done || !isChecked) {\n\t\t\tsetIsChecked(true);\n\t\t}*/\n\t\telse {\n\t\t\tsetIsChecked(!isChecked);\n\t\t}\n\t}\n\treturn (\n\t\t<div\n\t\t\tclassName={clsx('custom-checkbox-container')}\n\t\t\tonClick={onClick}\n\t\t>\n\t\t\t<input\n\t\t\t\ttype=\"checkbox\"\n\t\t\t\tchecked={isChecked}\n\t\t\t\t//onChange={() => setIsChecked(!isChecked)}\n\t\t\t\tonChange={() => onChange()}\n\t\t\t\tclassName={clsx('custom-checkbox')}\n\t\t\t/>\n\t\t\t<span\n\t\t\t\t// TODO : Voir meilleur moyen pour le .checked ?\n\t\t\t\tclassName={clsx('custom-visible-checkbox', { 'checked': isChecked || done })}\n\t\t\t\t//onClick={() => setIsChecked(!isChecked)}\n\t\t\t\tonClick={() => onChange()}\n\t\t\t></span>\n\t\t</div>\n\t);\n};\n\nCustomCheckbox.propTypes = {\n\tonClick: PropTypes.func.isRequired,\n\tdone: PropTypes.bool.isRequired,\n};\n\nexport default CustomCheckbox;","import React, { useState } from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\n\n//import styles from './TodoItem.module.css';\nimport './TodoItem.css';\nimport { useDispatch } from 'react-redux';\nimport { editTodo, removeTodo, toggleTodo } from './TodoSlice';\nimport CustomCheckbox from '../../../components/CustomCheckbox/CustomCheckbox';\nimport axios from 'axios';\n\n// TODO : Voir si mieux de passer \"text\" en props ou le chercher via un sélecteur ? VOIR POUR ID => id étant ds une func\n/*\n* TODO :\n*  => Faire en sorte que l'input (en mode editing) prenne tout le li sans rien faire bouger\n* */\n// TODO : Unifier Redux et API (completed = true / false au front et \"fait\" / \"non\" au back. Text au front et title au back pour le titre,…)\nconst TodoItempp = ({ id, text, /*edit,*/ todo }) => {\n\tconst dispatch = useDispatch();\n\t\n\t/*const onInputChange = (e) => {\n\t\tconst newValue = e.target.value;\n\t\tedit(id, newValue);\n\t};*/\n\t\n\t/*return (\n\t\t<li\n\t\t\t// TODO : Si un todo n'est pas class .done, il ne peut pas être checked dans CustomCheckbox\n\t\t\tclassName={clsx('todo-item', { 'done': todo.completed })}\n\t\t\t//onClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\t// TODO : Si on utilise <label> pour le texte de l'item, placer le onDblClick sur label ?\n\t\t\t//onDoubleClick={() => setIsEditing(true)}\n\t\t>\n\t\t\t<CustomCheckbox\n\t\t\t\tonClick={() => changeTodoStatus()}\n\t\t\t\tdone={todo.completed}\n\t\t\t/>\n\t\t\t<label\n\t\t\t\t// TODO : Revoir le css du label ?\n\t\t\t\tonDoubleClick={() => setIsEditing(true)}\n\t\t\t>{\n\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\ttodo.text\n\t\t\t}</label>\n\t\t\t<button\n\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\tonClick={() => deleteTodo()}\n\t\t\t>\n\t\t\t\t&times;\n\t\t\t</button>\n\t\t</li>\n\t)*/\n\t\n\tconst [isEditing, setIsEditing] = useState(false);\n\tconst [isEditingValue, setIsEditingValue] = useState(todo.text);\n\t\n\t/*const edit = (e) => {\n\t\tconst newTodoText = isEditingValue.trim();\n\t\tif (isEditing) {\n\t\t\t// TODO : Voir si on utiliser e.nativeEvent.type est dangereux ?\n\t\t\tif (e.which === 13 || e.nativeEvent.type === 'blur') {\n\t\t\t\tif (newTodoText.length === 0) {\n\t\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdispatch(editTodo({ id: todo.id, text: newTodoText }));\n\t\t\t\t}\n\t\t\t\t//dispatch(editTodo(todo.id));\n\t\t\t\tsetIsEditing(false);\n\t\t\t}\n\t\t}\n\t};*/\n\t\n\t// TODO : trim() ne fonctionne pas (on peut ajouter un espace à la fin ou début du todo en editant)\n\tconst edit = async (e) => {\n\t\tconst newTodoText = isEditingValue.trim();\n\t\t\n\t\tif (isEditing) {\n\t\t\ttry {\n\t\t\t\tif (e.which === 13 || e.nativeEvent.type === 'blur') {\n\t\t\t\t\tif (newTodoText.length === 0) {\n\t\t\t\t\t\t// TODO : Utiliser obj config pour l'ID du todo ?\n\t\t\t\t\t\t// TODO : Utiliser config authorizationToken ?\n\t\t\t\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\t\t\tconsole.log('removed success', res.data);\n\t\t\t\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\t\t\t\ttitle: newTodoText.trim()\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\t\t\tconsole.log('edit success', res.data);\n\t\t\t\t\t\t\tdispatch(editTodo({ id: todo.id, text: newTodoText.trim() }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsetIsEditing(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\t// TODO : Comment afficher erreur avec alerte \"générale\" ?\n\t\t\t\t// TODO : Faire 2 try / catch pour catch err si suppr ou si edit ? Ou un seul pour les 2 est bon ?\n\t\t\t\tconsole.error('Err edit todo', err);\n\t\t\t}\n\t\t\t// TODO : Voir si on utiliser e.nativeEvent.type est dangereux ?\n\t\t}\n\t};\n\t\n\tconst deleteTodo = async () => {\n\t\ttry {\n\t\t\tconst res = await axios.delete('http://localhost:3000/todos/' + todo.id);\n\t\t\t\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\tdispatch(removeTodo(todo.id));\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Err deleteTodo', err);\n\t\t}\n\t};\n\t\n\t// TODO : Modifier la date \"done_on\" si on passe le status à \"fait\" et le suppr si on passe à \"non\"\n\tconst changeTodoStatus = async () => {\n\t\ttry {\n\t\t\tconst status = todo.completed ? 'non': 'fait';\n\t\t\tlet done_on;\n\t\t\t\n\t\t\t// TODO : Fixer la date pour avoir la bonne du client (ici on a -1h avec new Date())\n\t\t\tif (status === 'fait') done_on = new Date();\n\t\t\telse done_on = null;\n\t\t\t\n\t\t\tconst res = await axios.put('http://localhost:3000/todos/' + todo.id, {\n\t\t\t\tstatus,\n\t\t\t\tdone_on\n\t\t\t});\n\t\t\t\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\tdispatch(toggleTodo(todo.id));\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Err changeTodoStatus', err);\n\t\t}\n\t};\n\t\n\tconst editingInput = () => {\n\t\n\t};\n\t\n\t// TODO : Quand on sort de isEditing, le .checked de checkbox disparait mais le style du li reste (= done)\n\tif (isEditing) {\n\t\treturn (\n\t\t\t<li\n\t\t\t\tclassName={clsx('todo-item', 'editing')}\n\t\t\t\t//onClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\t>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue={isEditingValue}\n\t\t\t\t\tonChange={e => setIsEditingValue(e.target.value)}\n\t\t\t\t\tonBlur={e => edit(e)}\n\t\t\t\t\t// TODO : Changer le outline du :focus (background-color ?)\n\t\t\t\t\tautoFocus={true}\n\t\t\t\t\tonKeyDown={e => edit(e)}\n\t\t\t\t/>\n\t\t\t</li>\n\t\t)\n\t}\n\telse {\n\t\t// TODO : Si todo.completed : ajouter .checked sur CustomCheckbox\n\t\treturn (\n\t\t\t<li\n\t\t\t\t// TODO : Si un todo n'est pas class .done, il ne peut pas être checked dans CustomCheckbox\n\t\t\t\tclassName={clsx('todo-item', { 'done': todo.completed })}\n\t\t\t\t//onClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\t\t// TODO : Si on utilise <label> pour le texte de l'item, placer le onDblClick sur label ?\n\t\t\t\t//onDoubleClick={() => setIsEditing(true)}\n\t\t\t>\n\t\t\t\t<CustomCheckbox\n\t\t\t\t\tonClick={() => changeTodoStatus()}\n\t\t\t\t\tdone={todo.completed}\n\t\t\t\t/>\n\t\t\t\t<label\n\t\t\t\t\t// TODO : Revoir le css du label ?\n\t\t\t\t\tonDoubleClick={() => setIsEditing(true)}\n\t\t\t\t>{\n\t\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\t\ttodo.text\n\t\t\t\t}</label>\n\t\t\t\t<button\n\t\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\t\tonClick={() => deleteTodo()}\n\t\t\t\t>\n\t\t\t\t\t&times;\n\t\t\t\t</button>\n\t\t\t</li>\n\t\t)\n\t}\n\t\n\t/*return (\n\t\t<li\n\t\t\tclassName={clsx('todo-item', { 'done': todo.completed })}\n\t\t\tonClick={() => dispatch(toggleTodo(todo.id))}\n\t\t\tonDoubleClick={() => setIsEditing(true)}\n\t\t>\n\t\t\t{\n\t\t\t\tisEditing &&\n\t\t\t\t<input type=\"text\" value={todo.text} onChange={e => setIsEditingValue(e.target.value)} />\n\t\t\t}\n\t\t\t{\n\t\t\t\t// TODO : Retourner le nom du todo => Chercher dans le state => selector ? Ou en props ?\n\t\t\t\ttodo.text\n\t\t\t}\n\t\t\t<button\n\t\t\t\t// TODO : Pourquoi utiliser ::after pour afficher le contenu (comme &times; ?) (comme ça dans todo-mvc-css)\n\t\t\t\tclassName=\"delete-todo\"\n\t\t\t\tonClick={() => dispatch(removeTodo(todo.id))}\n\t\t\t\tonDoubleClick={() => doubleClickTodo(todo.id)}\n\t\t\t>\n\t\t\t\t&times;\n\t\t\t</button>\n\t\t</li>\n\t);*/\n};\n\nTodoItempp.propTypes = {\n\ttodo: PropTypes.shape({\n\t\tid: PropTypes.number.isRequired,\n\t\ttext: PropTypes.string.isRequired,\n\t\tcompleted: PropTypes.bool.isRequired\n\t}).isRequired\n};\n\nexport default TodoItempp;","import React, { useEffect, useRef, useState } from 'react';\n\nimport './TodoList.css';\nimport TodoItempp from './TodoItempp';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { addTodo, addTodosFromDB, selectVisibleTodos } from './TodoSlice';\n\nimport axios from 'axios';\n\n/*\n* TODO : Général :\n*  => Centrer le tout et mettre un max-width ?\n*  => Rendre responsive\n*  => Styliser le tout\n*\n* TODO : AddTodo.js :\n*  => Ajouter un bouton \"Marquer tout comme fait\" (Redux => toggleAll)\n*\n* TODO : TodoList.js :\n*  => Modifier le onClick (Item.js) => Ne pas déclarer comme \"done\" au click\n*   => Ajouter une checkbox pour mettre un item en \"done\"\n*     => Styliser la checkbox (image ? css => .checkbox:cheked + label => Mettre le text de l'item en tant que label ?)\n*  => Ajouter \"Edit item\" (ouvre un input au lieu de l'item, avec son text déjà dedans) pour éditer un item\n*   => Fait mais utilise onBlur ou enter pour valider. Si on edit un item et qu'on ne va pas dans l'input, l'input\n*  ne s'enlève pas (étant donné qu'il faut passer dedans puis dehors pour le retirer)\n* */\n//let todos;\n\nconst TodoList = () => {\n\tconst dispatch = useDispatch();\n\tlet todos = useSelector(selectVisibleTodos);\n\t//const [todoss, setTodoss] = useState([]);\n\t\n\t/*useEffect(() => {\n\t\t(async () => {\n\t\t\t//let response= await fetchData(\"https://api.coindesk.com/v1/bpi/currentprice.json\");\n\t\t\t//setData(response);\n\t\t\ttry {\n\t\t\t\tconst res = await axios.get('http://localhost:3000/todos');\n\t\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\t\t//setTodos(res.data.todoss);\n\t\t\t\t\ttodos = res.data.todos;\n\t\t\t\t\treturn res.data.todos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tconsole.error('ERR GETDBTODOS', err);\n\t\t\t}\n\t\t\t\n\t\t})();\n\t}, []);*/\n\t\n\tconst getDBTodos = async () => {\n\t\ttry {\n\t\t\tconst res = await axios.get('http://localhost:3000/todos');\n\t\t\tif (res.status === 200 || res.data.status === 'success') {\n\t\t\t\ttodos = res.data.todos;\n\t\t\t\t// TODO : Dispatch tous les todos d'un coup au lieu de loop un à un\n\t\t\t\tfor (let i in todos) {\n\t\t\t\t\tdispatch(addTodosFromDB(todos[i]));\n\t\t\t\t}\n\t\t\t\t//return res.data.todos;\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('ERR GETDBTODOS', err);\n\t\t}\n\t};\n\t\n\tuseEffect(() => {\n\t\tgetDBTodos();\n\t}, []);\n\t\n\tconst editTodo = (id, newTitle) => {\n\t\tconst todosCopy = [...todos];\n\t\tfor (let todo of todosCopy) {\n\t\t\tif (todo.id === id) {\n\t\t\t\ttodo.text = newTitle;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tconst newTodo = (todo) => {\n\t\treturn (\n\t\t\t<TodoItempp\n\t\t\t\tkey={todo.id}\n\t\t\t\tid={todo.id}\n\t\t\t\ttext={todo.text}\n\t\t\t\tedit={editTodo}\n\t\t\t\ttodo={todo}\n\t\t\t/>\n\t\t);\n\t};\n\t\n\treturn (\n\t\t<div className=\"todolist-container\">\n\t\t\t<ul className=\"todo-list\">\n\t\t\t\t{/*{\n\t\t\t\t\ttodos.map(todo => (\n\t\t\t\t\t\t<TodoItem key={todo.id} todo={todo} />\n\t\t\t\t\t))\n\t\t\t\t}*/}\n\t\t\t\t{\n\t\t\t\t\ttodos.map(newTodo)\n\t\t\t\t}\n\t\t\t</ul>\n\t\t</div>\n\t);\n};\n\nexport default TodoList;","import React/*, { useEffect, useState } */from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\n\nimport './FilterLink.css';\n\n// TODO : Comment faire le onClick ici ? (différencier activeFilter de filter ici et pas dans Footer.js ?)\nconst FilterLink = ({ filter, onClick, activeFilter, children }) => {\n\t/*const [active, setActive] = useState(false);\n\t\n\tconst dispatch = useDispatch();\n\t\n\tfunction filterLinkClick(filter) {\n\t\tif (active) {\n\t\t\tsetActive(false);\n\t\t}\n\t\tdispatch(setVisibilityFilter(filter));\n\t}*/\n\t\n\treturn (\n\t\t<button\n\t\t\t// TODO : onClick => setVisibilityFilter\n\t\t\t//onClick={() => filterLinkClick(filter)}\n\t\t\tonClick={onClick}\n\t\t\t//className=\"filter-link\"\n\t\t\tclassName={clsx('filter-link', { 'active': activeFilter === filter })}\n\t\t>\n\t\t\t{ children }\n\t\t</button>\n\t);\n};\n\nFilterLink.propTypes = {\n\tfilter: PropTypes.oneOf([\n\t\t'SHOW_ALL',\n\t\t'SHOW_ACTIVE',\n\t\t'SHOW_COMPLETED'\n\t]).isRequired,\n\tactiveFilter: PropTypes.oneOf([ // TODO : Comment mettre null ? Retirer isRequired ?\n\t\t'SHOW_ALL',\n\t\t'SHOW_ACTIVE',\n\t\t'SHOW_COMPLETED'\n\t]),\n\tonClick: PropTypes.func.isRequired,\n\tchildren: PropTypes.string.isRequired,\n};\n\nexport default FilterLink;","import React, { /*useEffect,*/ useState } from 'react';\n\nimport './Footer.css';\nimport FilterLink from './FilterLink';\nimport { setVisibilityFilter, VisibilityFilters } from './FilterSlice';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { selectUndoneTodosNumber } from '../TodoList/TodoSlice';\n\n/*\n* TODO :\n*  => Cacher les FilterLink si pas d'item\n*  => Animer en transitions + styles :\n*  => Ajouter un bouton général \"supprimer les terminés\"\n* */\nconst Footer = () => {\n\t// TODO : Comment mieux gérer (- de props) activeFilter ? (et le onClick en général ? => Répétition des props)\n\tconst [activeFilter, setActiveFilter] = useState(null);\n\tconst dispatch = useDispatch();\n\t\n\tconst undoneTodosNumber = useSelector(selectUndoneTodosNumber);\n\tconst todosLeftWord = undoneTodosNumber > 1 ? 'tâches restantes' : 'tâche restante';\n\t\n\tfunction toggleFilter(filter) {\n\t\tsetActiveFilter(filter);\n\t\tdispatch(setVisibilityFilter(filter));\n\t}\n\t\n\treturn (\n\t\t<div className=\"footer\">\n\t\t\t<span className=\"undone-todos\">\n\t\t\t\t{ undoneTodosNumber || 'Aucune' } { todosLeftWord }\n\t\t\t</span>\n\t\t\t<div className=\"filters\">\n\t\t\t\t<FilterLink\n\t\t\t\t\tfilter={VisibilityFilters.SHOW_ALL}\n\t\t\t\t\tonClick={() => toggleFilter(VisibilityFilters.SHOW_ALL)}\n\t\t\t\t\tactiveFilter={activeFilter}\n\t\t\t\t>\n\t\t\t\t\tTous\n\t\t\t\t</FilterLink>\n\t\t\t\t<FilterLink\n\t\t\t\t\tfilter={VisibilityFilters.SHOW_COMPLETED}\n\t\t\t\t\tonClick={() => toggleFilter(VisibilityFilters.SHOW_COMPLETED)}\n\t\t\t\t\tactiveFilter={activeFilter}\n\t\t\t\t>\n\t\t\t\t\tFaits\n\t\t\t\t</FilterLink>\n\t\t\t\t<FilterLink\n\t\t\t\t\tfilter={VisibilityFilters.SHOW_ACTIVE}\n\t\t\t\t\tonClick={() => toggleFilter(VisibilityFilters.SHOW_ACTIVE)}\n\t\t\t\t\tactiveFilter={activeFilter}\n\t\t\t\t>\n\t\t\t\t\tA faire\n\t\t\t\t</FilterLink>\n\t\t\t</div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\nexport default Footer;","import { useState, useEffect } from 'react';\n\nfunction useKeyPress(targetKey) {\n\t// State for keeping track of which key is pressed\n\tconst [keyPressed, setKeyPressed] = useState(false);\n\t\n\t// If pressed key is our target key then set to true\n\tfunction downHandler(key) {\n\t\tconsole.log('key', key);\n\t\tconsole.log('ke{øy', {key});\n\t\tif (key === targetKey) setKeyPressed(true);\n\t}\n\t\n\t// If released key is our target key then set to false\n\tconst upHandler = ({ key }) => {\n\t\tif (key === targetKey) setKeyPressed(false);\n\t};\n\t\n\t// Add event listeners\n\tuseEffect(() => {\n\t\twindow.addEventListener('keydown', downHandler);\n\t\twindow.addEventListener('keyup', upHandler);\n\t\t// Remove event listeners on cleanup\n\t\treturn () => {\n\t\t\twindow.removeEventListener('keydown', downHandler);\n\t\t\twindow.removeEventListener('keyup', upHandler);\n\t\t}\n\t}, []);\n\t\n\treturn keyPressed;\n}\n\nexport default useKeyPress;","import { useEffect } from 'react';\n\nfunction useOnClickOutside(ref, handler) {\n\tuseEffect(() => {\n\t\tconst listener = (event) => {\n\t\t\t// Do nothing if clicking ref's element or descendent elements\n\t\t\tif (!ref.current || ref.current.contains(event.target))\n\t\t\t\treturn;\n\t\t\t\n\t\t\thandler(event);\n\t\t};\n\t\t\n\t\tdocument.addEventListener('mousedown', listener);\n\t\tdocument.addEventListener('touchstart', listener);\n\t\t\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('mousedown', listener);\n\t\t\tdocument.removeEventListener('touchstart', listener);\n\t\t};\n\t\t// Add ref and handler to effect dependencies\n\t\t// It's worth noting that because passed in handler is a new ...\n\t\t// ... function on every render that will cause this effect ...\n\t\t// ... callback/cleanup to run every render. It's not a big deal ...\n\t\t// ... but to optimize you can wrap handler in useCallback before ...\n\t\t// ... passing it into this hook.\n\t}, [ref, handler]);\n}\n\nexport default useOnClickOutside;","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport useKeyPress from '../../hooks/useKeyPress';\nimport useOnClickOutside from '../../hooks/useOnClickOutside';\n\nimport './InlineEdit.css';\n\nfunction InlineEdit(props) {\n\tconst [isInputActive, setIsInputActive] = useState(false);\n\tconst [inputValue, setInputValue] = useState(props.text);\n\t\n\t// Get the wrapping span node\n\tconst wrapperRef = useRef(null);\n\tconst textRef = useRef(null);\n\tconst inputRef = useRef(null);\n\t\n\tconst enter = useKeyPress('Enter');\n\tconst esc = useKeyPress('Escape');\n\t\n\tconst { onSetText } = props;\n\t\n\t// This hook takes a ref to watch and a Fn to run if the click happened outside\n\tuseOnClickOutside(wrapperRef, () => {\n\t\tif (isInputActive) {\n\t\t\t// Save the value and close the editor\n\t\t\tprops.onSetText(inputValue);\n\t\t\tsetIsInputActive(false);\n\t\t}\n\t});\n\t\n\tconst onEnter = useCallback(() => {\n\t\tif (enter) {\n\t\t\tonSetText(inputValue);\n\t\t\tsetIsInputActive(false);\n\t\t}\n\t}, [enter, inputValue, onSetText]);\n\t\n\tconst onEsc = useCallback(() => {\n\t\tif (esc) {\n\t\t\tsetInputValue(props.text);\n\t\t\tsetIsInputActive(false);\n\t\t}\n\t}, [esc, inputValue, onSetText]);\n\t\n\t// Focus the cursor in the input field on edit start\n\tuseEffect(() => {\n\t\tif (isInputActive) {\n\t\t\tinputRef.current.focus();\n\t\t}\n\t}, [isInputActive]);\n\t\n\tuseEffect(() => {\n\t\tif (isInputActive) {\n\t\t\t// if Enter is pressed, save the text and close the editor\n\t\t\tonEnter();\n\t\t\t// if Escape is pressed, revert the text and close the editor\n\t\t\tonEsc();\n\t\t}\n\t}, [onEnter, onEsc, isInputActive]); // Watch the Enter and Escape key presses\n\t\n\t//const handleInputChange = useCallback(\n\t//\tevent => {\n\t//\t\t// sanitize the input a little\n\t//\t\tsetInputValue(DOMPurify.sanitize(event.target.value));\n\t//\t},\n\t//\t[setInputValue]\n\t//);\n\t\n\t\n\tconst handleSpanClick = useCallback(() => setIsInputActive(true),\n\t\t[setIsInputActive]\n\t);\n\t\n\treturn (\n\t\t<span className=\"inline-text\" ref={wrapperRef}>\n\t\t\t<span\n\t\t\t\tref={textRef}\n\t\t\t\tonClick={handleSpanClick}\n\t\t\t\tclassName={`inline-text_copy inline-text_copy--${\n\t\t\t\t\t!isInputActive ? \"active\" : \"hidden\"\n\t\t\t\t}`}\n\t\t\t>\n\t\t\t\t{ props.text }\n\t\t\t</span>\n\t\t\t\n\t\t\t<input\n\t\t\t\tref={inputRef}\n\t\t\t\t// set the width to the input length multiplied by the x height\n\t\t\t\t// it's not quite right but gets it close\n\t\t\t\tstyle={{ width: Math.ceil(inputValue.length * 0.9) + \"ex\" }}\n\t\t\t\tvalue={inputValue}\n\t\t\t\tonChange={e => {\n\t\t\t\t\tsetInputValue(e.target.value);\n\t\t\t\t}}\n\t\t\t\tclassName={`inline-text_input inline-text_input--${\n\t\t\t\t\tisInputActive ? \"active\" : \"hidden\"\n\t\t\t\t}`}\n\t\t\t/>\n\t\t</span>\n\t);\n}\n\nexport default InlineEdit;","import React, { useState } from 'react';\n\nimport './assets/reset.css';\nimport './assets/general.css';\n\nimport './features/TodoList/todos.css';\nimport AddTodoForm from './features/TodoList/TodoList/AddTodoForm';\nimport TodoList from './features/TodoList/TodoList/TodoList';\nimport Footer from './features/TodoList/Filter/Footer';\nimport InlineEdit from './components/InlineEdit/InlineEdit';\n\nfunction App() {\n\t\n\tconst [storedHeading, setStoredHeading] = useState(\n\t\t\"Click here to start editing the text!\"\n\t);\n\tconst [storedText, setStoredText] = useState(\"Here's some more, edit away!\");\n\t\n\t\n\treturn (\n\t\t/*<Grid />*/\n\t\t<>\n\t\t\t{/*<Header/>\n\t\t\t <Cards/>\n\t\t\t <Accordion\n\t\t\t title=\"1er volet\"\n\t\t\t >\n\t\t\t <p>Ceci est le 1er paragraphe de l'accordion. Il parle du Lion que voici :</p>\n\t\t\t <p>Le Lion est un spécimène très rare et recherché de nos jours. On l'aime pour ses poils doux et velus.</p>\n\t\t\t </Accordion>\n\t\t\t <div className=\"todos\">\n\t\t\t <AddTodoForm/>\n\t\t\t <TodoList/>\n\t\t\t <Footer/>\n\t\t\t </div>*/}\n\t\t\t<div className=\"todos\">\n\t\t\t\t<h2>\n\t\t\t\t\t{/* Not editable right here.{\" \"} */}\n\t\t\t\t\t<InlineEdit\n\t\t\t\t\t\ttext={storedHeading}\n\t\t\t\t\t\tonSetText={text => setStoredHeading(text)}\n\t\t\t\t\t/>\n\t\t\t\t</h2>\n\t\t\t\t<p>\n\t\t\t\t\t<InlineEdit text={storedText} onSetText={text => setStoredText(text)} />\n\t\t\t\t</p>\n\t\t\t\t<AddTodoForm/>\n\t\t\t\t<TodoList/>\n\t\t\t\t<Footer/>\n\t\t\t</div>\n\t\t</>\n\t);\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { configureStore } from '@reduxjs/toolkit';\nimport TodoSlice from '../features/TodoList/TodoList/TodoSlice';\nimport FilterSlice from '../features/TodoList/Filter/FilterSlice';\n\nconst store = configureStore({\n\treducer: {\n\t\ttodos: TodoSlice,\n\t\tfilters: FilterSlice,\n\t}\n});\n\nexport default store;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport store from './App/store';\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<Provider store={store}>\n\t\t\t<App />\n\t\t</Provider>\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}